// Generated by CoffeeScript 1.6.1
(function() {
  var CenterServerInterface, ES, EasySettings, EventEmitter, LocalSession, Main, NodeInterface, PublicServer, PublicSession, WebSocket, WebSocketServer, centerServer, centerServerConfig, centerServerIp, centerServerPort, events, localPort, nodePort, p2pnodeConfig, rpc, rsaModule, ws,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ws = require("ws");

  WebSocket = ws;

  WebSocketServer = ws.Server;

  rsaModule = require("../common/rsa.coffee");

  centerServer = "localhost";

  rpc = require("../common/rpc.coffee");

  centerServerConfig = require("../config/centerServer.coffee");

  p2pnodeConfig = require("../config/p2pnode.coffee");

  events = require("events");

  EventEmitter = events.EventEmitter;

  EasySettings = (require("easysettings")).EasySettings;

  ES = new EasySettings("p2pdata.conf.json");

  centerServerIp = centerServerConfig.ip;

  centerServerPort = centerServerConfig.port;

  nodePort = p2pnodeConfig.port;

  localPort = p2pnodeConfig.localPort;

  LocalSession = (require("./localSession.coffee")).LocalSession;

  PublicSession = (require("./publicSession.coffee")).PublicSession;

  CenterServerInterface = (require("./centerServerInterface.coffee")).CenterServerInterface;

  NodeInterface = (require("./nodeInterface")).NodeInterface;

  PublicServer = (function(_super) {

    __extends(PublicServer, _super);

    function PublicServer(rsa) {
      var _this = this;
      this.server = new WebSocketServer({
        port: nodePort,
        host: "0.0.0.0"
      });
      this.sessionList = [];
      this.maxNodeCountReturn = 50;
      this.getCountIndex = 0;
      this.rsa = rsa;
      this._buildRSA(function() {
        return _this._buildServer();
      });
    }

    PublicServer.prototype._buildRSA = function(callback) {
      var _this = this;
      if (this.rsa && this.rsa.publicKey && this.rsa.privateKey) {
        this.publicKey = this.rsa.publicKey;
        this.privateKey = this.rsa.privateKey;
        if (typeof callback === "function") {
          return callback();
        }
      } else {
        this.rsa = {};
        return rsaModule.generatePrivateKey(function(err, key) {
          if (err) {
            console.error("fail to generate rsa private key");
            throw err;
          }
          _this.rsa.privateKey = key.toString();
          return rsaModule.generatePublicKey(_this.rsa.privateKey, function(err, key) {
            if (err) {
              console.error("fail to generate rsa public key");
              throw err;
            }
            _this.rsa.publicKey = key;
            _this.publicKey = _this.rsa.publicKey;
            _this.privateKey = _this.rsa.privateKey;
            _this.emit("rsaChange");
            if (typeof callback === "function") {
              callback();
            }
            return callback();
          });
        });
      }
    };

    PublicServer.prototype._buildServer = function() {
      var _this = this;
      return this.server.on("connection", function(ws) {
        var index, item, session, useIt, _i, _len, _ref;
        useIt = false;
        session = new PublicSession(new rpc.NodeWSTunnel(ws), _this);
        _ref = _this.sessionList;
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          item = _ref[index];
          if (item.nodeIp === session.nodeIp) {
            _this.sessionList.splice(index, 1);
            _this.sessionList.push(session);
            useIt = true;
            break;
          }
        }
        if (!useIt) {
          return _this.sessionList.push(session);
        }
      });
    };

    PublicServer.prototype.getNodes = function(count) {
      var index, results;
      if (count > this.maxNodeCountReturn) {
        count = this.maxNodeCountReturn;
      }
      if (this.sessionList.length === 0) {
        callback(null, []);
      }
      index = this.getCountIndex;
      results = [];
      while (true) {
        while (this.sessionList.length > index) {
          results.push(this.sessionList[index].nodeIp);
          if (results.length >= count) {
            break;
          }
          index++;
          if (index === this.getCountIndex) {
            break;
          }
        }
        if (results.length >= count) {
          break;
        }
        if (this.sessionList.length === index) {
          index = 0;
        }
        if (index === this.getCountIndex) {
          break;
        }
      }
      return results;
    };

    return PublicServer;

  })(EventEmitter);

  Main = (function() {

    function Main() {
      var _this = this;
      this.configDatas = ES.load();
      this.centerServer = new CenterServerInterface(centerServerIp);
      this.centerServer.on("close", function() {
        console.warn("connection to center server is closed");
        console.log("reopen");
        return _this.centerServer = new CenterServerInterface(centerServerIp);
      });
      this.publicServer = new PublicServer(this.configDatas.rsa);
      this.publicServer.on("rsaChange", function() {
        return _this.save();
      });
      this.buildNodes();
      this.maintainInterval = 1000 * 5;
      setInterval((function() {
        _this.maintainNodeLinks();
        console.log("currentNodes", _this.nodeList);
        return console.log({
          "authedNodes": _this.authedNodeList
        });
      }), this.maintainInterval);
    }

    Main.prototype.sayHelloToCenterServer = function() {
      return this.getMoreNodes();
    };

    Main.prototype.buildNodes = function() {
      this.knownNodes = this.configDatas.knownNodes || [];
      this.nodeList = this.configDatas.nodeList || [];
      this.authedNodeList = [];
      return this.maintainNodeLinks();
    };

    Main.prototype.maintainNodeLinks = function() {
      this.getMoreNodes();
      return this.linkNodes();
    };

    Main.prototype.linkNodes = function() {
      var authed, ip, item, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = this.nodeList;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ip = _ref[_i];
        authed = false;
        _ref1 = this.authedNodeList;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          item = _ref1[_j];
          if (item.ips && __indexOf.call(item.ips, ip) >= 0) {
            authed = true;
            break;
          }
        }
        if (authed) {
          continue;
        }
        _results.push(this.autherizeNode(ip));
      }
      return _results;
    };

    Main.prototype.saveNodes = function() {
      this.configDatas.knownNodes = this.knownNodes;
      return this.configDatas.nodeList = this.nodeList;
    };

    Main.prototype.save = function() {
      this.saveNodes();
      this.configDatas.rsa = this.publicServer.rsa;
      return ES.save();
    };

    Main.prototype.getMoreNodes = function() {
      var _this = this;
      return this.centerServer.getNodes(100, function(err, nodes) {
        var ip, _i, _len, _results;
        console.log("more nodes", nodes.length);
        if (err) {
          console.log("center server error", err);
          return;
        }
        _results = [];
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          ip = nodes[_i];
          if (__indexOf.call(_this.nodeList, ip) < 0) {
            _results.push(_this.nodeList.push(ip));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    };

    Main.prototype.boardCast = function(info) {
      var inf, ip, node, _i, _len, _ref, _results;
      _ref = this.authedNodeList;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        ip = node.ips[node.ips.length - 1];
        if (!ip) {
          continue;
        }
        inf = new NodeInterface(ip);
        _results.push(inf.provide(JSON.stringify(info)));
      }
      return _results;
    };

    Main.prototype.addAuthedNode = function(ip, pubkey) {
      var info, item, _i, _len, _ref;
      _ref = this.knownNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.pubkey === pubkey) {
          item.ips = item.ips || [];
          item.ips.push(ip);
          this.authedNodeList.push(item);
          return;
        }
      }
      info = {
        pubkey: pubkey,
        ips: [ip]
      };
      this.authedNodeList.push(info);
      return this.knownNodes.push(info);
    };

    Main.prototype.autherizeNode = function(ip) {
      var nodeInterface,
        _this = this;
      console.log("autherizeNode:ip", ip);
      nodeInterface = new NodeInterface(ip);
      return nodeInterface.getPublicKey(function(err, pubkey) {
        var rawToken;
        if (err) {
          console.error("fail to get pubkey", err);
          return;
        }
        rawToken = (Math.random()).toString();
        return rsaModule.encrypt(new Buffer(rawToken), pubkey, function(err, data) {
          if (err) {
            console.error("fail to enc rawToken");
            return;
          }
          return nodeInterface.autherize(data.toString("base64"), function(err, result) {
            var returnToken;
            if (err) {
              console.log("fail to remove autherize");
              return;
            }
            returnToken = new Buffer(result, "base64").toString();
            if (returnToken !== rawToken) {
              console.log("sign failed");
              return;
            }
            return _this.addAuthedNode(ip, pubkey);
          });
        });
      });
    };

    return Main;

  })();

  exports.main = new Main();

}).call(this);
